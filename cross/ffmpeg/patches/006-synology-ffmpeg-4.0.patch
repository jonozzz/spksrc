diff -Nru ../FFmpeg-n4.0.4/configure ./configure
--- ../FFmpeg-n4.0.4/configure	2019-04-18 13:18:37.683662103 -0700
+++ ./configure	2019-04-18 13:19:20.259938332 -0700
@@ -6049,7 +6049,8 @@
 enabled librsvg           && require_pkg_config librsvg librsvg-2.0 librsvg-2.0/librsvg/rsvg.h rsvg_handle_render_cairo
 enabled librtmp           && require_pkg_config librtmp librtmp librtmp/rtmp.h RTMP_Socket
 enabled librubberband     && require_pkg_config librubberband "rubberband >= 1.8.1" rubberband/rubberband-c.h rubberband_new -lstdc++ && append librubberband_extralibs "-lstdc++"
-enabled libshine          && require_pkg_config libshine shine shine/layer3.h shine_encode_buffer
+#enabled libshine          && require_pkg_config libshine shine shine/layer3.h shine_encode_buffer
+enabled libshine          && require shine shine/layer3.h shine_encode_buffer -lm -lshine
 enabled libsmbclient      && { check_pkg_config libsmbclient smbclient libsmbclient.h smbc_init ||
                                require libsmbclient libsmbclient.h smbc_init -lsmbclient; }
 enabled libsnappy         && require libsnappy snappy-c.h snappy_compress -lsnappy -lstdc++
diff -Nru ../FFmpeg-n4.0.4/fftools/ffmpeg_opt.c ./fftools/ffmpeg_opt.c
--- ../FFmpeg-n4.0.4/fftools/ffmpeg_opt.c	2019-03-27 01:33:52.000000000 -0700
+++ ./fftools/ffmpeg_opt.c	2019-04-18 13:19:20.259938332 -0700
@@ -41,6 +41,12 @@
 #include "libavutil/pixdesc.h"
 #include "libavutil/pixfmt.h"
 
+#include "synoconfig.h"
+
+#ifdef SYNO_DTV_SKIP_UNKNOWN_TRACK
+#include <strings.h>
+#endif
+
 #define DEFAULT_PASS_LOGFILENAME_PREFIX "ffmpeg2pass"
 
 #define MATCH_PER_STREAM_OPT(name, type, outvar, fmtctx, st)\
@@ -110,7 +116,15 @@
 int filter_nbthreads = 0;
 int filter_complex_nbthreads = 0;
 int vstats_version = 2;
-
+#ifdef SYNO_DTV_SKIP_UNKNOWN_TRACK
+int dtv_skip_unknown = 0;
+#endif
+#ifdef SYNO_DTV_SKIP_VISUAL_IMPAIRED_TRACK
+int dtv_skip_visual_impaired = 0;
+#endif
+#ifdef SYNO_DTV_SKIP_TELETEXT
+int dtv_skip_teletext = 0;
+#endif
 
 static int intra_only         = 0;
 static int file_overwrite     = 0;
@@ -339,6 +353,33 @@
                 if (check_stream_specifier(input_files[file_idx]->ctx, input_files[file_idx]->ctx->streams[i],
                             *p == ':' ? p + 1 : p) <= 0)
                     continue;
+#ifdef SYNO_DTV_SKIP_UNKNOWN_TRACK
+				if (dtv_skip_unknown) {
+					char buf[256];
+					AVStream *st = input_files[file_idx]->ctx->streams[i];
+					avcodec_string(buf, sizeof(buf), st->codec, 0);
+					if (!strncasecmp(buf, "unknown", 7)) {
+						continue;
+					}
+					if (strstr(buf, "0 channels") != NULL) {
+						continue;
+					}
+				}
+#endif
+#ifdef SYNO_DTV_SKIP_VISUAL_IMPAIRED_TRACK
+				if (dtv_skip_visual_impaired) {
+					AVStream *st = input_files[file_idx]->ctx->streams[i];
+					if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED) {
+						continue;
+					}
+				}
+#endif
+#ifdef SYNO_DTV_SKIP_TELETEXT
+                if (dtv_skip_teletext &&
+                    AV_CODEC_ID_DVB_TELETEXT == input_files[file_idx]->ctx->streams[i]->codec->codec_id) {
+                    continue;
+                }
+#endif
                 GROW_ARRAY(o->stream_maps, o->nb_stream_maps);
                 m = &o->stream_maps[o->nb_stream_maps - 1];
 
@@ -678,6 +719,38 @@
     return codec;
 }
 
+#ifdef SYNO_SKIP_DISABLED_AUDIO_STREAM
+static int IsAudioCopyStream(OptionsContext *o, AVFormatContext *oc)
+{
+	int ret = 0;
+	char *audio_codec_name = NULL;
+
+	MATCH_PER_TYPE_OPT(codec_names, str, audio_codec_name, oc, "a");
+
+	if (audio_codec_name && 0 == strcmp(audio_codec_name, "copy")) {
+		ret = 1;
+	}
+
+	return ret;
+}
+
+static int IsSkipAudioStream(const InputStream *ist, OptionsContext *o, AVFormatContext *oc)
+{
+	if (ist->st->codec->codec_id == AV_CODEC_ID_DTS
+		|| ist->st->codec->codec_id == AV_CODEC_ID_EAC3
+		|| ist->st->codec->codec_id == AV_CODEC_ID_TRUEHD
+		|| ist->st->codec->codec_id == AV_CODEC_ID_AC3)
+	{
+		// if not stream copy
+		if (!IsAudioCopyStream(o, oc)) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+#endif
+
 static AVCodec *choose_decoder(OptionsContext *o, AVFormatContext *s, AVStream *st)
 {
     char *codec_name = NULL;
@@ -2164,6 +2237,12 @@
             for (i = 0; i < nb_input_streams; i++) {
                 int score;
                 ist = input_streams[i];
+#ifdef SYNO_SKIP_DISABLED_AUDIO_STREAM
+				if (IsSkipAudioStream(ist, o, oc)) {
+					// if not stream copy
+					continue;
+				}
+#endif
                 score = ist->st->codecpar->channels + 100000000*!!ist->st->codec_info_nb_frames;
                 if (ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&
                     score > best_score) {
@@ -2253,6 +2332,12 @@
                     continue;
                 if(o->    data_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_DATA)
                     continue;
+#ifdef SYNO_SKIP_DISABLED_AUDIO_STREAM
+				if (IsSkipAudioStream(ist, o, oc)) {
+					// if not stream copy
+					continue;
+				}
+#endif
 
                 ost = NULL;
                 switch (ist->st->codecpar->codec_type) {
@@ -3292,6 +3377,19 @@
 const OptionDef options[] = {
     /* main options */
     CMDUTILS_COMMON_OPTIONS
+#ifdef SYNO_DTV_SKIP_UNKNOWN_TRACK
+    { "dtv_skip_unknown",        OPT_BOOL,                                    {              &dtv_skip_unknown},
+        "skip unknown codec track during dtv streaming" },
+#endif
+#ifdef SYNO_DTV_SKIP_VISUAL_IMPAIRED_TRACK
+    { "dtv_skip_visual_impaired",        OPT_BOOL,                   {              &dtv_skip_visual_impaired },
+        "skip visual impaired track during dtv streaming" },
+#endif
+#ifdef SYNO_DTV_SKIP_TELETEXT
+    { "dtv_skip_teletext", OPT_BOOL,                                 {              &dtv_skip_teletext },
+        "skip subtitle streams in teletext codec during dtv streaming" },
+#endif
+
     { "f",              HAS_ARG | OPT_STRING | OPT_OFFSET |
                         OPT_INPUT | OPT_OUTPUT,                      { .off       = OFFSET(format) },
         "force format", "fmt" },
diff -Nru ../FFmpeg-n4.0.4/libavcodec/aacdec_template.c ./libavcodec/aacdec_template.c
--- ../FFmpeg-n4.0.4/libavcodec/aacdec_template.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/aacdec_template.c	2019-04-18 13:19:20.259938332 -0700
@@ -90,6 +90,8 @@
  */
 
 #include "libavutil/thread.h"
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
 
 static VLC vlc_scalefactors;
 static VLC vlc_spectral[11];
@@ -1171,6 +1173,12 @@
     avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;
 #endif /* USE_FIXED */
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("aac_dec")) {
+		return -1;
+	}
+#endif
+
     if (avctx->extradata_size > 0) {
         if ((ret = decode_audio_specific_config(ac, ac->avctx, &ac->oc[1].m4ac,
                                                 avctx->extradata,
diff -Nru ../FFmpeg-n4.0.4/libavcodec/aacenc.c ./libavcodec/aacenc.c
--- ../FFmpeg-n4.0.4/libavcodec/aacenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/aacenc.c	2019-04-18 13:19:20.263938358 -0700
@@ -48,6 +48,9 @@
 
 #include "psymodel.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 static AVOnce aac_table_init = AV_ONCE_INIT;
 
 static void put_pce(PutBitContext *pb, AVCodecContext *avctx)
@@ -964,6 +967,12 @@
     uint8_t grouping[AAC_MAX_CHANNELS];
     int lengths[2];
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("aac_enc")) {
+		return -1;
+	}
+#endif
+
     /* Constants */
     s->last_frame_pb_count = 0;
     avctx->frame_size = 1024;
diff -Nru ../FFmpeg-n4.0.4/libavcodec/ac3dec.c ./libavcodec/ac3dec.c
--- ../FFmpeg-n4.0.4/libavcodec/ac3dec.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/ac3dec.c	2019-04-18 13:19:20.263938358 -0700
@@ -41,6 +41,9 @@
 #include "ac3dec_data.h"
 #include "kbdwin.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 /**
  * table for ungrouping 3 values in 7 bits.
  * used for exponents and bap=2 mantissas
@@ -186,6 +189,12 @@
     AC3DecodeContext *s = avctx->priv_data;
     int i;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("ac3_dec")) {
+		return -1;
+	}
+#endif
+
     s->avctx = avctx;
 
     ac3_tables_init();
diff -Nru ../FFmpeg-n4.0.4/libavcodec/h264dec.c ./libavcodec/h264dec.c
--- ../FFmpeg-n4.0.4/libavcodec/h264dec.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/h264dec.c	2019-04-18 13:19:20.263938358 -0700
@@ -55,6 +55,9 @@
 #include "rectangle.h"
 #include "thread.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 const uint16_t ff_h264_mb_sizes[4] = { 256, 384, 512, 768 };
 
 int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx)
@@ -394,6 +397,12 @@
     H264Context *h = avctx->priv_data;
     int ret;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("h264_dec")) {
+		return -1;
+	}
+#endif
+
     ret = h264_init_context(avctx, h);
     if (ret < 0)
         return ret;
diff -Nru ../FFmpeg-n4.0.4/libavcodec/h264_parser.c ./libavcodec/h264_parser.c
--- ../FFmpeg-n4.0.4/libavcodec/h264_parser.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/h264_parser.c	2019-04-18 13:19:20.263938358 -0700
@@ -47,6 +47,8 @@
 #include "mpegutils.h"
 #include "parser.h"
 
+#include "synoconfig.h"
+
 typedef struct H264ParseContext {
     ParseContext pc;
     H264ParamSets ps;
@@ -108,8 +110,13 @@
                 state >>= 1;           // 2->1, 1->0, 0->0
         } else if (state <= 5) {
             int nalu_type = buf[i] & 0x1F;
+#ifdef SYNO_FIX_MP4_REMUX_H264PARSER
+            if (nalu_type == H264_NAL_SEI || nalu_type == H264_NAL_SPS ||
+                nalu_type == H264_NAL_AUD) {
+#else
             if (nalu_type == H264_NAL_SEI || nalu_type == H264_NAL_SPS ||
                 nalu_type == H264_NAL_PPS || nalu_type == H264_NAL_AUD) {
+#endif
                 if (pc->frame_start_found) {
                     i++;
                     goto found;
diff -Nru ../FFmpeg-n4.0.4/libavcodec/hevcdec.c ./libavcodec/hevcdec.c
--- ../FFmpeg-n4.0.4/libavcodec/hevcdec.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/hevcdec.c	2019-04-18 13:19:20.263938358 -0700
@@ -44,6 +44,9 @@
 #include "hwaccel.h"
 #include "profiles.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
 
 /**
@@ -3455,6 +3458,12 @@
     HEVCContext *s = avctx->priv_data;
     int ret;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("hevc_dec")) {
+		return -1;
+	}
+#endif
+
     avctx->internal->allocate_progress = 1;
 
     ret = hevc_init_context(avctx);
diff -Nru ../FFmpeg-n4.0.4/libavcodec/libfdk-aacdec.c ./libavcodec/libfdk-aacdec.c
--- ../FFmpeg-n4.0.4/libavcodec/libfdk-aacdec.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/libfdk-aacdec.c	2019-04-18 13:24:52.998100662 -0700
@@ -213,6 +213,12 @@
     FDKAACDecContext *s = avctx->priv_data;
     AAC_DECODER_ERROR err;
 
+#ifdef SYNO_CODEC_PATENT_G1
+   if (0 != ActivateCodec("aac_dec")) {
+       return -1;
+   }
+#endif
+
     s->handle = aacDecoder_Open(avctx->extradata_size ? TT_MP4_RAW : TT_MP4_ADTS, 1);
     if (!s->handle) {
         av_log(avctx, AV_LOG_ERROR, "Error opening decoder\n");
@@ -296,6 +302,9 @@
         }
     }
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 #ifdef AACDECODER_LIB_VL0
     if (aacDecoder_SetParam(s->handle, AAC_PCM_LIMITER_ENABLE, s->level_limit) != AAC_DEC_OK) {
         av_log(avctx, AV_LOG_ERROR, "Unable to set in signal level limiting in the decoder\n");
diff -Nru ../FFmpeg-n4.0.4/libavcodec/libfdk-aacenc.c ./libavcodec/libfdk-aacenc.c
--- ../FFmpeg-n4.0.4/libavcodec/libfdk-aacenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/libfdk-aacenc.c	2019-04-18 13:19:20.267938385 -0700
@@ -26,6 +26,9 @@
 #include "audio_frame_queue.h"
 #include "internal.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 typedef struct AACContext {
     const AVClass *class;
     HANDLE_AACENCODER handle;
@@ -114,6 +117,12 @@
     int aot = FF_PROFILE_AAC_LOW + 1;
     int sce = 0, cpe = 0;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("aac_enc")) {
+		return -1;
+	}
+#endif
+
     if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENC_OK) {
         av_log(avctx, AV_LOG_ERROR, "Unable to open the encoder: %s\n",
                aac_get_error(err));
diff -Nru ../FFmpeg-n4.0.4/libavcodec/libx264.c ./libavcodec/libx264.c
--- ../FFmpeg-n4.0.4/libavcodec/libx264.c	2019-04-18 13:18:42.043690385 -0700
+++ ./libavcodec/libx264.c	2019-04-18 13:19:20.267938385 -0700
@@ -40,6 +40,9 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 typedef struct X264Context {
     AVClass        *class;
     x264_param_t    params;
@@ -459,6 +462,12 @@
     AVCPBProperties *cpb_props;
     int sw,sh;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("h264_enc")) {
+		return -1;
+	}
+#endif
+
     if (avctx->global_quality > 0)
         av_log(avctx, AV_LOG_WARNING, "-qscale is ignored, -crf is recommended.\n");
 
diff -Nru ../FFmpeg-n4.0.4/libavcodec/Makefile ./libavcodec/Makefile
--- ../FFmpeg-n4.0.4/libavcodec/Makefile	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/Makefile	2019-04-18 13:19:20.267938385 -0700
@@ -51,6 +51,8 @@
        vorbis_parser.o                                                  \
        xiph.o                                                           \
 
+OBJS += synog1codecpatent.o
+
 # subsystems
 OBJS-$(CONFIG_AANDCTTABLES)            += aandcttab.o
 OBJS-$(CONFIG_AC3DSP)                  += ac3dsp.o ac3.o ac3tab.o
diff -Nru ../FFmpeg-n4.0.4/libavcodec/mpeg4videodec.c ./libavcodec/mpeg4videodec.c
--- ../FFmpeg-n4.0.4/libavcodec/mpeg4videodec.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/mpeg4videodec.c	2019-04-18 13:19:20.271938410 -0700
@@ -37,6 +37,9 @@
 #include "thread.h"
 #include "xvididct.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 /* The defines below define the number of bits that are read at once for
  * reading vlc values. Changing these may improve speed and data cache needs
  * be aware though that decreasing them may need the number of stages that is
@@ -3412,6 +3415,12 @@
     MpegEncContext *s = &ctx->m;
     int ret;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("mpeg4part2_dec")) {
+		return -1;
+	}
+#endif
+
     ctx->divx_version =
     ctx->divx_build   =
     ctx->xvid_build   =
diff -Nru ../FFmpeg-n4.0.4/libavcodec/mpeg4videoenc.c ./libavcodec/mpeg4videoenc.c
--- ../FFmpeg-n4.0.4/libavcodec/mpeg4videoenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/mpeg4videoenc.c	2019-04-18 13:19:20.271938410 -0700
@@ -28,6 +28,9 @@
 #include "h263.h"
 #include "mpeg4video.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
+
 /* The uni_DCtab_* tables below contain unified bits+length tables to encode DC
  * differences in MPEG-4. Unified in the sense that the specification specifies
  * this encoding in several steps. */
@@ -1279,6 +1282,12 @@
         return AVERROR(EINVAL);
     }
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("mpeg4part2_enc")) {
+		return -1;
+	}
+#endif
+
     if ((ret = ff_mpv_encode_init(avctx)) < 0)
         return ret;
 
diff -Nru ../FFmpeg-n4.0.4/libavcodec/ppc/blockdsp.c ./libavcodec/ppc/blockdsp.c
--- ../FFmpeg-n4.0.4/libavcodec/ppc/blockdsp.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/ppc/blockdsp.c	2019-04-18 13:19:20.271938410 -0700
@@ -32,6 +32,8 @@
 
 #include "libavcodec/blockdsp.h"
 
+#include "synoconfig.h"
+
 /* ***** WARNING ***** WARNING ***** WARNING ***** */
 /*
  * clear_blocks_dcbz32_ppc will not work properly on PowerPC processors with
@@ -115,7 +117,15 @@
 
     /* Below the constraint "b" seems to mean "address base register"
      * in gcc-3.3 / RS/6000 speaks. Seems to avoid using r0, so.... */
+#ifdef SYNO_FIX_QORIQ_CORE_DUMP
+	#if SYNO_PLATFORM == PPC_QORIQ || defined(SYNO_PLAT_TRANSCODE_FOR_QORIQ)
+	__asm__ volatile("dcbz %0, %1" : : "r" (fakedata_middle), "r" (zero));
+	#else
+	__asm__ volatile("dcbzl %0, %1" : : "b" (fakedata_middle), "r" (zero));
+	#endif
+#else
     __asm__ volatile ("dcbzl %0, %1" :: "b" (fakedata_middle), "r" (zero));
+#endif
 
     for (i = 0; i < 1024; i++)
         if (fakedata[i] == (char) 0)
diff -Nru ../FFmpeg-n4.0.4/libavcodec/srtenc.c ./libavcodec/srtenc.c
--- ../FFmpeg-n4.0.4/libavcodec/srtenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/srtenc.c	2019-04-18 13:19:20.271938410 -0700
@@ -26,6 +26,7 @@
 #include "ass_split.h"
 #include "ass.h"
 
+#include "synoconfig.h"
 
 #define SRT_STACK_SIZE 64
 
@@ -193,7 +194,9 @@
 static void srt_cancel_overrides_cb(void *priv, const char *style)
 {
     srt_stack_push_pop(priv, 0, 1);
+ #ifndef SYNO_FILTER_SRT_TAGS
     srt_style_apply(priv, style);
+#endif
 }
 
 static void srt_move_cb(void *priv, int x1, int y1, int x2, int y2,
@@ -221,6 +224,21 @@
     .end              = srt_end_cb,
 };
 
+#ifdef SYNO_FILTER_SRT_TAGS
+static const ASSCodesCallbacks srt_callbacks_syno_notag = {
+    .text             = srt_text_cb,
+    .new_line         = srt_new_line_cb,
+    .style            = NULL,
+    .color            = NULL,
+    .font_name        = NULL,
+    .font_size        = NULL,
+    .alignment        = NULL,
+    .cancel_overrides = srt_cancel_overrides_cb,
+    .move             = NULL,
+    .end              = srt_end_cb,
+};
+#endif
+
 static const ASSCodesCallbacks text_callbacks = {
     .text             = srt_text_cb,
     .new_line         = srt_new_line_cb,
@@ -250,9 +268,13 @@
             dialog = ff_ass_split_dialog(s->ass_ctx, ass, 0, &num);
             for (; dialog && num--; dialog++) {
                 s->alignment_applied = 0;
+#ifdef SYNO_FILTER_SRT_TAGS
+                ff_ass_split_override_codes(&srt_callbacks_syno_notag, s, dialog->text);
+#else
                 if (avctx->codec_id == AV_CODEC_ID_SUBRIP)
                     srt_style_apply(s, dialog->style);
                 ff_ass_split_override_codes(cb, s, dialog->text);
+#endif
             }
         } else {
 #endif
diff -Nru ../FFmpeg-n4.0.4/libavcodec/synog1codecpatent.c ./libavcodec/synog1codecpatent.c
--- ../FFmpeg-n4.0.4/libavcodec/synog1codecpatent.c	1969-12-31 16:00:00.000000000 -0800
+++ ./libavcodec/synog1codecpatent.c	2019-04-18 13:19:20.271938410 -0700
@@ -0,0 +1,186 @@
+#ifndef MY_ABC_HERE
+#define MY_ABC_HERE
+#endif
+#include "synoconfig.h"
+
+#ifdef SYNO_CODEC_PATENT_G1
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include "synog1codecpatent.h"
+
+#if defined(MY_ABC_HERE)
+#define SZ_BIN_SYNOCODECPATENT "/var/packages/VideoStation/target/bin/synocodectool"
+#elif defined(SYNO_AUDIOSTATION)
+#define SZ_BIN_SYNOCODECPATENT "/var/packages/AudioStation/target/bin/synocodectool"
+#elif defined(SYNO_MEDIASERVER)
+#define SZ_BIN_SYNOCODECPATENT "/var/packages/MediaServer/target/bin/synocodectool"
+#else
+#define SZ_BIN_SYNOCODECPATENT "/usr/syno/bin/synocodectool"
+#endif
+
+static pid_t SYNOProcForkEx(void)
+{
+	int pid = -1;
+	int fd = -1;
+	int	status = 0;
+	int waitRet = 0;
+	char *pEnvPath = NULL;
+
+	fflush(NULL);
+
+	pid = fork();
+	if (0 > pid) {
+		return -1;
+	} else if (pid > 0) {
+		while (-1 == (waitRet = waitpid(pid, &status, 0)) && EINTR == errno) {
+			//do nothing
+		}
+		if (-1 != waitRet && 0 == WEXITSTATUS(status)) {
+			return 1;
+		} else if (-1 == waitRet && errno == ECHILD) {
+			return 1;
+		}
+		return -1;
+	}
+
+	pEnvPath = getenv("PATH");
+	if (pEnvPath) {
+		setenv("PATH", pEnvPath, 1);
+	}
+
+	if (-1 != (fd = open("/dev/null", O_RDWR, 0))) {
+		(void) dup2(fd, STDIN_FILENO);
+		(void) dup2(fd, STDOUT_FILENO);
+		(void) dup2(fd, STDERR_FILENO);
+		if (2 < fd)
+			(void) close(fd);
+	}
+
+	setsid();
+	chdir("/");
+
+	return 0;
+}
+
+static int SYNOExecl(const char *szPath, const char* szArg, ...)
+{
+    int ret=-1, pid, nowait, status=0;
+	int	fChildAlive = 0;
+	struct sigaction	saOrg;
+	size_t i = 0;
+	size_t argc = 0;
+	const char *arg = NULL;
+	const char **argv = NULL;
+	va_list ap;
+
+	// remove SA_NOCLDWAIT flags if set
+	sigaction(SIGCHLD, NULL, &saOrg);
+	nowait = (saOrg.sa_flags & SA_NOCLDWAIT);
+	saOrg.sa_flags &= ~SA_NOCLDWAIT;
+	sigaction(SIGCHLD, &saOrg, NULL);
+
+	if ((pid = SYNOProcForkEx()) == 0) {
+		arg = szArg;
+		va_start(ap, szArg);
+		for(argc = 2; NULL != arg; ++argc) {
+			arg = va_arg(ap, const char*);
+		}
+		va_end(ap);
+
+		argv = (const char**) calloc (argc, sizeof(const char*));
+
+		arg = szArg;
+		argv[0] = szPath;
+		argv[1] = szArg;
+		va_start(ap, szArg);
+		for (i = 2; NULL != arg; ++i) {
+			arg = va_arg(ap, const char*);
+			argv[i] = arg;
+		}
+		va_end(ap);
+
+		execv(szPath, (char *const *) argv);
+
+		free(argv);
+		// If any of the exec functions returns, an error will have occurred.  The return value is 255
+		_exit(-1);
+	} else if (pid != -1) {
+		while (-1 == (fChildAlive = waitpid(pid, &status, 0)) && EINTR == errno);
+		if (-1 != fChildAlive && WIFEXITED(status)) {
+			//child alive --> wait until child done and check its exit code.
+			ret = WEXITSTATUS(status);
+		} else if ( fChildAlive == -1 && errno == ECHILD ) {
+			//child doesn't alive --> see as success
+			ret = 0;
+		}
+	}
+	// restore SA_NOCLDWAIT flag if orginal set
+	if (nowait) {
+		sigaction(SIGCHLD, NULL, &saOrg);
+		saOrg.sa_flags |= SA_NOCLDWAIT;
+		sigaction(SIGCHLD, &saOrg, NULL);
+	}
+	return ret;
+}
+
+static int FileExit(const char *szPath)
+{
+	int iRet = 0;
+	struct stat statBuf;
+
+	if (!szPath) {
+		goto Exit;
+	}
+	if (0 == stat(szPath, &statBuf) && S_ISREG(statBuf.st_mode)) {
+		iRet = 1;
+	}
+Exit:
+	return iRet;
+
+}
+
+/**
+ * check the codec can use,
+ * active, 0
+ * not active or error, -1
+ */
+int ActivateCodec(const char *szCodecName)
+{
+	int iRet = -1;
+	char *szEnvSkipActivate = NULL;
+
+	//for some case like avformat_find_stream_info, don't need avtivate mechanism.
+	szEnvSkipActivate = getenv(SZ_SYNO_CODEC_SKIP_ACTIVATION);
+	if (szEnvSkipActivate && 0 == strcmp(szEnvSkipActivate, "yes")) {
+		return 0;
+	}
+
+	if (!szCodecName) {
+		goto Exit;
+	}
+
+	if (!FileExit(SZ_BIN_SYNOCODECPATENT)) {
+		goto Exit;
+	}
+
+	if (0 != SYNOExecl(SZ_BIN_SYNOCODECPATENT, "--check_codec_activated", szCodecName, "--pkgname", SZ_PKG_NAME, NULL)) {
+		if (0 != SYNOExecl(SZ_BIN_SYNOCODECPATENT, "--activate_codec", szCodecName, "--pkgname", SZ_PKG_NAME, NULL)) {
+			goto Exit;
+		}
+	}
+
+	iRet = 0;
+Exit:
+	return iRet;
+}
+#endif //SYNO_CODEC_PATENT_G1
diff -Nru ../FFmpeg-n4.0.4/libavcodec/synog1codecpatent.h ./libavcodec/synog1codecpatent.h
--- ../FFmpeg-n4.0.4/libavcodec/synog1codecpatent.h	1969-12-31 16:00:00.000000000 -0800
+++ ./libavcodec/synog1codecpatent.h	2019-04-18 13:19:20.275938436 -0700
@@ -0,0 +1,27 @@
+#ifndef MY_ABC_HERE
+#define MY_ABC_HERE
+#endif
+#ifndef _SYNO_G1_CODEC_PATENT_H
+#define _SYNO_G1_CODEC_PATENT_H
+
+#include "synoconfig.h"
+
+#ifdef SYNO_CODEC_PATENT_G1
+
+#define SZ_SYNO_CODEC_SKIP_ACTIVATION "SYNO_CODEC_SKIP_ACTIVATION"
+
+//TODO must change by define by package
+#if defined(MY_ABC_HERE)
+#define SZ_PKG_NAME "videostation"
+#elif defined(SYNO_AUDIOSTATION)
+#define SZ_PKG_NAME "audiostation"
+#elif defined(SYNO_MEDIASERVER)
+#define SZ_PKG_NAME "mediaserver"
+#else
+#define SZ_PKG_NAME "dsm"
+#endif
+
+int ActivateCodec(const char *szCodecName);
+#endif //SYNO_CODEC_PATENT_G1
+
+#endif //_SYNO_G1_CODEC_PATENT_H
diff -Nru ../FFmpeg-n4.0.4/libavcodec/vaapi_encode.c ./libavcodec/vaapi_encode.c
--- ../FFmpeg-n4.0.4/libavcodec/vaapi_encode.c	2019-04-18 13:18:49.943741631 -0700
+++ ./libavcodec/vaapi_encode.c	2019-04-18 13:19:20.275938436 -0700
@@ -27,6 +27,8 @@
 #include "vaapi_encode.h"
 #include "avcodec.h"
 #include "internal.h"
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
 
 static const char * const picture_type_name[] = { "IDR", "I", "P", "B" };
 
@@ -1389,6 +1391,12 @@
     VAStatus vas;
     int err;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("h264_enc")) {
+		return -1;
+	}
+#endif
+
     if (!avctx->hw_frames_ctx) {
         av_log(avctx, AV_LOG_ERROR, "A hardware frames reference is "
                "required to associate the encoding device.\n");
diff -Nru ../FFmpeg-n4.0.4/libavcodec/vc1dec.c ./libavcodec/vc1dec.c
--- ../FFmpeg-n4.0.4/libavcodec/vc1dec.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavcodec/vc1dec.c	2019-04-18 13:19:20.275938436 -0700
@@ -40,6 +40,8 @@
 #include "vc1data.h"
 #include "libavutil/avassert.h"
 
+#include "synoconfig.h"
+#include "synog1codecpatent.h"
 
 #if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER
 
@@ -426,6 +428,12 @@
     GetBitContext gb;
     int ret;
 
+#ifdef SYNO_CODEC_PATENT_G1
+	if (0 != ActivateCodec("vc1_dec")) {
+		return -1;
+	}
+#endif
+
     /* save the container output size for WMImage */
     v->output_width  = avctx->width;
     v->output_height = avctx->height;
diff -Nru ../FFmpeg-n4.0.4/libavformat/flacdec.c ./libavformat/flacdec.c
--- ../FFmpeg-n4.0.4/libavformat/flacdec.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/flacdec.c	2019-04-18 13:19:20.275938436 -0700
@@ -144,12 +144,14 @@
             }
             av_freep(&buffer);
         } else if (metadata_type == FLAC_METADATA_TYPE_PICTURE) {
+#ifndef SYNO_SKIP_FLAC_PARSE_PICTURE
             ret = ff_flac_parse_picture(s, buffer, metadata_size);
             av_freep(&buffer);
             if (ret < 0) {
                 av_log(s, AV_LOG_ERROR, "Error parsing attached picture.\n");
                 return ret;
             }
+#endif
         } else if (metadata_type == FLAC_METADATA_TYPE_SEEKTABLE) {
             const uint8_t *seekpoint = buffer;
             int i, seek_point_count = metadata_size/SEEKPOINT_SIZE;
diff -Nru ../FFmpeg-n4.0.4/libavformat/matroskaenc.c ./libavformat/matroskaenc.c
--- ../FFmpeg-n4.0.4/libavformat/matroskaenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/matroskaenc.c	2019-04-18 13:19:20.275938436 -0700
@@ -56,6 +56,8 @@
 #include "libavcodec/mpeg4audio.h"
 #include "libavcodec/internal.h"
 
+#include "synoconfig.h"
+
 typedef struct ebml_master {
     int64_t         pos;                ///< absolute offset in the file where the master's elements start
     int             sizebytes;          ///< how many bytes were reserved for the size
@@ -161,9 +163,13 @@
     int64_t* stream_duration_offsets;
 
     int allow_raw_vfw;
+#ifdef SYNO_VIDEOSTATION_WEBM_SEEK_TIME
+	int64_t seek_time;
+	AVPacket old_key_packet;
+	int unfilled;
+#endif
 } MatroskaMuxContext;
 
-
 /** 2 bytes * 3 for EBML IDs, 3 1-byte EBML lengths, 8 bytes for 64 bit
  * offset, 4 bytes for target EBML ID */
 #define MAX_SEEKENTRY_SIZE 21
@@ -2026,6 +2032,11 @@
             mkv->cluster_size_limit = 32 * 1024;
     }
 
+#ifdef SYNO_VIDEOSTATION_WEBM_SEEK_TIME
+	av_init_packet(&mkv->old_key_packet);
+	mkv->unfilled = 1;
+#endif
+
     return 0;
 fail:
     mkv_free(mkv);
@@ -2426,6 +2437,41 @@
     if (ret < 0)
         return ret;
 
+#ifdef SYNO_VIDEOSTATION_WEBM_SEEK_TIME
+	int64_t pts = AV_NOPTS_VALUE;
+	if (0 < mkv->seek_time && mkv->unfilled) {
+		if (codec_type != AVMEDIA_TYPE_VIDEO) {
+			return 0;
+		}
+
+		if (pkt->pts != AV_NOPTS_VALUE) {
+			pts = pkt->pts;
+		} else if (pkt->dts != AV_NOPTS_VALUE) {
+			pts = pkt->dts;
+		}
+		if (pts >= 0) {
+			if (pkt->flags & AV_PKT_FLAG_KEY) {
+				mkv->unfilled = 0;
+			} else if (NULL != mkv->old_key_packet.data) {
+				mkv->old_key_packet.pts = pkt->pts;
+				mkv->old_key_packet.dts = pkt->dts;
+				mkv->old_key_packet.duration = pkt->duration;
+				av_free_packet(pkt);
+				av_init_packet(pkt);
+				av_copy_packet(pkt, &mkv->old_key_packet);
+				mkv->unfilled = 0;
+			}
+			av_free_packet(&mkv->old_key_packet);
+		} else {
+			if (pkt->flags & AV_PKT_FLAG_KEY) {
+				av_free_packet(&mkv->old_key_packet);
+				av_copy_packet(&mkv->old_key_packet, pkt);
+			}
+			return 0;
+		}
+	}
+#endif
+
     if (mkv->tracks[pkt->stream_index].write_dts)
         cluster_time = pkt->dts - mkv->cluster_pts;
     else
@@ -2736,6 +2782,9 @@
     { "live", "Write files assuming it is a live stream.", OFFSET(is_live), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, FLAGS },
     { "allow_raw_vfw", "allow RAW VFW mode", OFFSET(allow_raw_vfw), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, FLAGS },
     { "write_crc32", "write a CRC32 element inside every Level 1 element", OFFSET(write_crc), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, FLAGS },
+#ifdef SYNO_VIDEOSTATION_WEBM_SEEK_TIME
+    { "webm_seek_time",    "seek time", OFFSET(seek_time), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, FLAGS },
+#endif
     { NULL },
 };
 
diff -Nru ../FFmpeg-n4.0.4/libavformat/movenc.c ./libavformat/movenc.c
--- ../FFmpeg-n4.0.4/libavformat/movenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/movenc.c	2019-04-18 13:26:21.906679239 -0700
@@ -98,6 +98,9 @@
     { "encryption_kid", "The media encryption key identifier (hex)", offsetof(MOVMuxContext, encryption_kid), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },
     { "use_stream_ids_as_track_ids", "use stream ids as track ids", offsetof(MOVMuxContext, use_stream_ids_as_track_ids), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},
     { "write_tmcd", "force or disable writing tmcd", offsetof(MOVMuxContext, write_tmcd), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},
+#ifdef SYNO_VIDEOSTATION_SKIP_DISPLAYMATRIX
+    { "skip_displaymatrix", "Skip writing displaymatrix metadata.", offsetof(MOVMuxContext, skip_displaymatrix), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},
+#endif
     { NULL },
 };
 
@@ -2769,6 +2772,11 @@
                                                             &display_matrix_size);
         if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))
             display_matrix = NULL;
+#ifdef SYNO_VIDEOSTATION_SKIP_DISPLAYMATRIX
+        if (mov->skip_displaymatrix) {
+            display_matrix = NULL;
+        }
+#endif
     }
 
     if (track->flags & MOV_TRACK_ENABLED)
diff -Nru ../FFmpeg-n4.0.4/libavformat/movenc.h ./libavformat/movenc.h
--- ../FFmpeg-n4.0.4/libavformat/movenc.h	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/movenc.h	2019-04-18 13:19:20.279938462 -0700
@@ -27,6 +27,8 @@
 #include "avformat.h"
 #include "movenccenc.h"
 
+#include "synoconfig.h"
+
 #define MOV_FRAG_INFO_ALLOC_INCREMENT 64
 #define MOV_INDEX_CLUSTER_SIZE 1024
 #define MOV_TIMESCALE 1000
@@ -184,6 +186,9 @@
     int rtp_flags;
 
     int iods_skip;
+#ifdef SYNO_VIDEOSTATION_SKIP_DISPLAYMATRIX
+    int skip_displaymatrix;
+#endif
     int iods_video_profile;
     int iods_audio_profile;
 
diff -Nru ../FFmpeg-n4.0.4/libavformat/segment.c ./libavformat/segment.c
--- ../FFmpeg-n4.0.4/libavformat/segment.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/segment.c	2019-04-18 13:19:20.279938462 -0700
@@ -43,6 +43,8 @@
 #include "libavutil/time_internal.h"
 #include "libavutil/timestamp.h"
 
+#include "synoconfig.h"
+
 typedef struct SegmentListEntry {
     int index;
     double start_time, end_time;
@@ -124,6 +126,12 @@
     SegmentListEntry cur_entry;
     SegmentListEntry *segment_list_entries;
     SegmentListEntry *segment_list_entries_end;
+
+#ifdef SYNO_VIDEOSTATION_HLS_SEEK_TIME
+	int64_t seek_time;
+	AVPacket old_key_packet;
+	int filled;
+#endif
 } SegmentContext;
 
 static void print_csv_escaped_str(AVIOContext *ctx, const char *str)
@@ -217,15 +225,30 @@
     ff_format_set_url(oc, new_name);
 
     /* copy modified name in list entry */
+#ifdef SYNO_HLS_COSTUMIZED_TS_NAME
+    const size_t SVS_FILE_NAME_LEN = 1024;
+    size = SVS_FILE_NAME_LEN;
+#else
     size = strlen(av_basename(oc->url)) + 1;
+#endif
     if (seg->entry_prefix)
         size += strlen(seg->entry_prefix);
 
     if ((ret = av_reallocp(&seg->cur_entry.filename, size)) < 0)
         return ret;
+#ifdef SYNO_HLS_COSTUMIZED_TS_NAME
+    snprintf(seg->cur_entry.filename, size, "%s%s",
+             seg->entry_prefix ? seg->entry_prefix : "",
+             oc->filename);
+#elif defined(SYNO_VIDEOSTATION_HLS_COSTUMIZED_TS_NAME)
+    snprintf(seg->cur_entry.filename, size, "%s%03d",
+             seg->entry_prefix ? seg->entry_prefix : "",
+             seg->segment_idx);
+#else
     snprintf(seg->cur_entry.filename, size, "%s%s",
              seg->entry_prefix ? seg->entry_prefix : "",
              av_basename(oc->url));
+#endif
 
     return 0;
 }
@@ -841,6 +864,10 @@
         if (!seg->individual_header_trailer)
             oc->pb->seekable = 0;
     }
+#ifdef SYNO_VIDEOSTATION_HLS_SEEK_TIME
+	av_init_packet(&seg->old_key_packet);
+	seg->filled = 1;
+#endif
 
     return 0;
 }
@@ -859,6 +886,40 @@
     if (!seg->avf || !seg->avf->pb)
         return AVERROR(EINVAL);
 
+#ifdef SYNO_VIDEOSTATION_HLS_SEEK_TIME
+	int64_t pts = AV_NOPTS_VALUE;
+	if (0 < seg->seek_time && seg->filled) {
+		if (pkt->stream_index != seg->reference_stream_index) {
+			return 0;
+		}
+
+		if (pkt->pts != AV_NOPTS_VALUE) {
+			pts = pkt->pts;
+		} else if (pkt->dts != AV_NOPTS_VALUE) {
+			pts = pkt->dts;
+		}
+		if (pts >= 0) {
+			if (pkt->flags & AV_PKT_FLAG_KEY) {
+				seg->filled = 0;
+			} else if (NULL != seg->old_key_packet.data) {
+				seg->old_key_packet.pts = pkt->pts;
+				seg->old_key_packet.dts = pkt->dts;
+				seg->old_key_packet.duration = pkt->duration;
+				av_free_packet(pkt);
+				av_init_packet(pkt);
+				av_copy_packet(pkt, &seg->old_key_packet);
+				seg->filled = 0;
+			}
+			av_free_packet(&seg->old_key_packet);
+		} else {
+			if (pkt->flags & AV_PKT_FLAG_KEY) {
+				av_free_packet(&seg->old_key_packet);
+				av_copy_packet(&seg->old_key_packet, pkt);
+			}
+			return 0;
+		}
+	}
+#endif
 calc_times:
     if (seg->times) {
         end_pts = seg->segment_count < seg->nb_times ?
@@ -945,6 +1006,14 @@
            av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, &st->time_base),
            av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, &st->time_base));
 
+#ifdef SYNO_VIDEOSTATION_HLS_SEEK_TIME
+	if (0 < seg->seek_time) {
+		if (pkt->pts != AV_NOPTS_VALUE)
+			pkt->pts += av_rescale_q(seg->seek_time, (AVRational) {1, 1000}, st->time_base);
+		if (pkt->dts != AV_NOPTS_VALUE)
+			pkt->dts += av_rescale_q(seg->seek_time, (AVRational) {1, 1000}, st->time_base);
+	}
+#endif
     ret = ff_write_chained(seg->avf, pkt->stream_index, pkt, s, seg->initial_offset || seg->reset_timestamps);
 
 fail:
@@ -1061,6 +1130,9 @@
     { "reset_timestamps", "reset timestamps at the beginning of each segment", OFFSET(reset_timestamps), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, E },
     { "initial_offset", "set initial timestamp offset", OFFSET(initial_offset), AV_OPT_TYPE_DURATION, {.i64 = 0}, -INT64_MAX, INT64_MAX, E },
     { "write_empty_segments", "allow writing empty 'filler' segments", OFFSET(write_empty), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, E },
+#ifdef SYNO_VIDEOSTATION_HLS_SEEK_TIME
+    { "hls_seek_time",    "initial segment start time", OFFSET(seek_time), AV_OPT_TYPE_INT64, {.i64 = 0}, 0, INT_MAX, E },
+#endif
     { NULL },
 };
 
diff -Nru ../FFmpeg-n4.0.4/libavformat/smoothstreamingenc.c ./libavformat/smoothstreamingenc.c
--- ../FFmpeg-n4.0.4/libavformat/smoothstreamingenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/smoothstreamingenc.c	2019-04-18 13:19:20.279938462 -0700
@@ -39,6 +39,8 @@
 #include "libavutil/mathematics.h"
 #include "libavutil/intreadwrite.h"
 
+#include "synoconfig.h"
+
 typedef struct Fragment {
     char file[1024];
     char infofile[1024];
@@ -77,6 +79,15 @@
     OutputStream *streams;
     int has_video, has_audio;
     int nb_fragments;
+#ifdef SYNO_SMOOTH_STREAMING
+	char *fragment_url;
+	int fragment_length;
+	int seek_time;
+#ifdef SYNO_EVANSPORT_SMOOTH_STREAMING_TIMESTAMP_INACCURATE
+	AVPacket old_key_packet;
+	int filled;
+#endif
+#endif
 } SmoothStreamingContext;
 
 static int ism_write(void *opaque, uint8_t *buf, int buf_size)
@@ -257,8 +268,13 @@
     avio_printf(out, ">\n");
     if (c->has_video) {
         int last = -1, index = 0;
-        avio_printf(out, "<StreamIndex Type=\"video\" QualityLevels=\"%d\" Chunks=\"%d\" Url=\"QualityLevels({bitrate})/Fragments(video={start time})\">\n", video_streams, video_chunks);
-        for (i = 0; i < s->nb_streams; i++) {
+#ifdef SYNO_SMOOTH_STREAMING
+	avio_printf(out, "<StreamIndex Type=\"video\" QualityLevels=\"%d\" Chunks=\"%d\" Url=\"%    sQualityLevels({bitrate})/Fragments(video={start time})\">\n", video_streams, video_chunks,
+					(NULL == c->fragment_url) ? "" :  c->fragment_url);
+#else
+		avio_printf(out, "<StreamIndex Type=\"video\" QualityLevels=\"%d\" Chunks=\"%d\" Url=\"QualityLevels({bitrate})/Fragments(video={start time})\">\n", video_streams, video_chunks);
+#endif
+		for (i = 0; i < s->nb_streams; i++) {
             OutputStream *os = &c->streams[i];
             if (s->streams[i]->codecpar->codec_type != AVMEDIA_TYPE_VIDEO)
                 continue;
@@ -271,8 +287,13 @@
     }
     if (c->has_audio) {
         int last = -1, index = 0;
-        avio_printf(out, "<StreamIndex Type=\"audio\" QualityLevels=\"%d\" Chunks=\"%d\" Url=\"QualityLevels({bitrate})/Fragments(audio={start time})\">\n", audio_streams, audio_chunks);
-        for (i = 0; i < s->nb_streams; i++) {
+#ifdef SYNO_SMOOTH_STREAMING
+avio_printf(out, "<StreamIndex Type=\"audio\" QualityLevels=\"%d\" Chunks=\"%d\" Url=\"%    sQualityLevels({bitrate})/Fragments(audio={start time})\">\n", audio_streams, audio_chunks,
+					(NULL == c->fragment_url) ? "" :  c->fragment_url);
+#else
+		avio_printf(out, "<StreamIndex Type=\"audio\" QualityLevels=\"%d\" Chunks=\"%d\" Url=\"QualityLevels({bitrate})/Fragments(audio={start time})\">\n", audio_streams, audio_chunks);
+#endif
+		for (i = 0; i < s->nb_streams; i++) {
             OutputStream *os = &c->streams[i];
             if (s->streams[i]->codecpar->codec_type != AVMEDIA_TYPE_AUDIO)
                 continue;
@@ -401,6 +422,9 @@
     }
     ret = write_manifest(s, 0);
 
+#ifdef SYNO_EVANSPORT_SMOOTH_STREAMING_TIMESTAMP_INACCURATE
+	av_init_packet(&c->old_key_packet);
+#endif
 fail:
     if (ret)
         ism_free(s);
@@ -541,7 +565,15 @@
         size = os->tail_pos - os->cur_start_pos;
         if ((ret = parse_fragment(s, filename, &start_ts, &duration, &moof_size, size)) < 0)
             break;
-        snprintf(header_filename, sizeof(header_filename), "%s/FragmentInfo(%s=%"PRIu64")", os->dirname, os->stream_type_tag, start_ts);
+#ifdef SYNO_SMOOTH_STREAMING
+		if (0 != c->fragment_length) {
+			start_ts = (int64_t)((int64_t)os->nb_fragments * (int64_t)c->fragment_length * (int64_t)10000000);
+		}
+		if (0 != c->seek_time) {
+			start_ts += (int64_t)((int64_t)c->seek_time * (int64_t)10000000);
+		}
+#endif
+		snprintf(header_filename, sizeof(header_filename), "%s/FragmentInfo(%s=%"PRIu64")", os->dirname, os->stream_type_tag, start_ts);
         snprintf(target_filename, sizeof(target_filename), "%s/Fragments(%s=%"PRIu64")", os->dirname, os->stream_type_tag, start_ts);
         copy_moof(s, filename, header_filename, moof_size);
         ret = ff_rename(filename, target_filename, s);
@@ -585,6 +617,34 @@
     int64_t end_dts = (c->nb_fragments + 1) * (int64_t) c->min_frag_duration;
     int ret;
 
+#ifdef SYNO_EVANSPORT_SMOOTH_STREAMING_TIMESTAMP_INACCURATE
+	if (c->has_video && 0 != c->seek_time && c->filled) {
+		if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO) {
+			return 0;
+		}
+		if (av_compare_ts(pkt->dts, st->time_base, (int64_t)((int64_t)c->seek_time * (int64_t)1000000), AV_TIME_BASE_Q) >= 0) {
+			if (pkt->flags & AV_PKT_FLAG_KEY) {
+				c->filled = 0;
+			} else if (NULL != c->old_key_packet.data) {
+				c->old_key_packet.pts = pkt->pts;
+				c->old_key_packet.dts = pkt->dts;
+				c->old_key_packet.duration = pkt->duration;
+				av_free_packet(pkt);
+				av_init_packet(pkt);
+				av_copy_packet(pkt, &c->old_key_packet);
+				c->filled = 0;
+			}
+			av_free_packet(&c->old_key_packet);
+		} else {
+			if (pkt->flags & AV_PKT_FLAG_KEY) {
+				av_free_packet(&c->old_key_packet);
+				av_copy_packet(&c->old_key_packet, pkt);
+			}
+			return 0;
+		}
+	}
+#endif
+
     if (st->first_dts == AV_NOPTS_VALUE)
         st->first_dts = pkt->dts;
 
@@ -626,7 +686,15 @@
     { "lookahead_count", "number of lookahead fragments", OFFSET(lookahead_count), AV_OPT_TYPE_INT, { .i64 = 2 }, 0, INT_MAX, E },
     { "min_frag_duration", "minimum fragment duration (in microseconds)", OFFSET(min_frag_duration), AV_OPT_TYPE_INT64, { .i64 = 5000000 }, 0, INT_MAX, E },
     { "remove_at_exit", "remove all fragments when finished", OFFSET(remove_at_exit), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, E },
-    { NULL },
+#ifdef SYNO_SMOOTH_STREAMING
+	{ "fragment_url", "set fragment url in manifest", OFFSET(fragment_url), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, E },
+    { "fragment_length", "let file name of output fragment mp4 with the duration (in seconds)", OFFSET(fragment_length), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, E },
+    { "seek_time", "add seek time to fragment file (in seconds)", OFFSET(seek_time), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, E },
+#ifdef SYNO_EVANSPORT_SMOOTH_STREAMING_TIMESTAMP_INACCURATE
+    { "filled", "filter out useless frame (hardware transcode)", OFFSET(filled), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, E },
+#endif
+#endif
+     { NULL },
 };
 
 static const AVClass ism_class = {
diff -Nru ../FFmpeg-n4.0.4/libavformat/utils.c ./libavformat/utils.c
--- ../FFmpeg-n4.0.4/libavformat/utils.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/utils.c	2019-04-18 13:19:20.283938488 -0700
@@ -54,6 +54,10 @@
 #include "url.h"
 
 #include "libavutil/ffversion.h"
+
+#include "synoconfig.h"
+#include "libavcodec/synog1codecpatent.h"
+
 const char av_format_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
 
 static AVMutex avformat_mutex = AV_MUTEX_INITIALIZER;
@@ -3548,7 +3552,14 @@
                 i->avctx->extradata = av_mallocz(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (!i->avctx->extradata) {
                 av_packet_unref(pkt_ref);
-                return AVERROR(ENOMEM);
+#ifdef SYNO_CODEC_PATENT_G1
+				{
+					unsetenv(SZ_SYNO_CODEC_SKIP_ACTIVATION);
+#endif
+					return AVERROR(ENOMEM);
+#ifdef SYNO_CODEC_PATENT_G1
+				}
+#endif
             }
             memcpy(i->avctx->extradata, extradata, extradata_size);
             i->avctx->extradata_size = extradata_size;
@@ -3577,6 +3588,10 @@
     int eof_reached = 0;
     int *missing_streams = av_opt_ptr(ic->iformat->priv_class, ic->priv_data, "missing_streams");
 
+#ifdef SYNO_CODEC_PATENT_G1
+	setenv(SZ_SYNO_CODEC_SKIP_ACTIVATION, "yes", 1);
+#endif
+
     flush_codecs = probesize > 0;
 
     av_opt_set(ic, "skip_clear", "1", AV_OPT_SEARCH_CHILDREN);
@@ -4158,6 +4173,9 @@
     if (ic->pb)
         av_log(ic, AV_LOG_DEBUG, "After avformat_find_stream_info() pos: %"PRId64" bytes read:%"PRId64" seeks:%d frames:%d\n",
                avio_tell(ic->pb), ic->pb->bytes_read, ic->pb->seek_count, count);
+#ifdef SYNO_CODEC_PATENT_G1
+	unsetenv(SZ_SYNO_CODEC_SKIP_ACTIVATION);
+#endif
     return ret;
 }
 
diff -Nru ../FFmpeg-n4.0.4/libavformat/wavenc.c ./libavformat/wavenc.c
--- ../FFmpeg-n4.0.4/libavformat/wavenc.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libavformat/wavenc.c	2019-04-18 13:19:20.283938488 -0700
@@ -46,6 +46,8 @@
 #include "internal.h"
 #include "riff.h"
 
+#include "synoconfig.h"
+
 #define RF64_AUTO   (-1)
 #define RF64_NEVER  0
 #define RF64_ALWAYS 1
@@ -84,6 +86,9 @@
     int peak_block_pos;
     int peak_ppv;
     int peak_bps;
+#ifdef SYNO_WRITE_RIFF_INFO_TAG_TO_WAV
+    int write_info_tag;
+#endif
 } WAVMuxContext;
 
 #if CONFIG_WAV_MUXER
@@ -356,7 +361,13 @@
 
     if (wav->write_peak != PEAK_ONLY) {
         /* info header */
+#ifdef SYNO_WRITE_RIFF_INFO_TAG_TO_WAV
+        if (wav->write_info_tag) {
+            ff_riff_write_info(s);
+        }
+#else
         ff_riff_write_info(s);
+#endif
 
         /* data header */
         wav->data = ff_start_tag(pb, "data");
@@ -506,6 +517,9 @@
     { "peak_block_size", "Number of audio samples used to generate each peak frame.",   OFFSET(peak_block_size), AV_OPT_TYPE_INT, { .i64 = 256 }, 0, 65536, ENC },
     { "peak_format",     "The format of the peak envelope data (1: uint8, 2: uint16).", OFFSET(peak_format), AV_OPT_TYPE_INT,     { .i64 = PEAK_FORMAT_UINT16 }, PEAK_FORMAT_UINT8, PEAK_FORMAT_UINT16, ENC },
     { "peak_ppv",        "Number of peak points per peak value (1 or 2).",              OFFSET(peak_ppv), AV_OPT_TYPE_INT, { .i64 = 2 }, 1, 2, ENC },
+#ifdef SYNO_WRITE_RIFF_INFO_TAG_TO_WAV
+    { "write_info_tag",      "Write RIFF info tag.",     OFFSET(write_info_tag),            AV_OPT_TYPE_INT, { .i64 = 1  }, 0, 1, ENC },
+#endif
     { NULL },
 };
 
diff -Nru ../FFmpeg-n4.0.4/libswscale/arm/Makefile ./libswscale/arm/Makefile
--- ../FFmpeg-n4.0.4/libswscale/arm/Makefile	2019-03-27 01:33:52.000000000 -0700
+++ ./libswscale/arm/Makefile	2019-04-18 13:19:20.283938488 -0700
@@ -1,8 +1,14 @@
-OBJS        += arm/swscale.o                    \
-               arm/swscale_unscaled.o           \
+OBJS        += arm/swscale_unscaled.o           \
 
 NEON-OBJS   += arm/rgb2yuv_neon_32.o
 NEON-OBJS   += arm/rgb2yuv_neon_16.o
 NEON-OBJS   += arm/hscale.o                     \
                arm/output.o                     \
                arm/yuv2rgb_neon.o               \
+
+#for SYNO_ALPINE_NEON_LIBSWSCALE
+ifeq ($(EXPORT_BUILD_TARGET), ALPINE)
+OBJS += arm/swscale_arm.o
+
+CFLAGS += -mfpu=neon-vfpv4 -flax-vector-conversions -std=gnu99
+endif
diff -Nru ../FFmpeg-n4.0.4/libswscale/arm/swscale_arm.c ./libswscale/arm/swscale_arm.c
--- ../FFmpeg-n4.0.4/libswscale/arm/swscale_arm.c	1969-12-31 16:00:00.000000000 -0800
+++ ./libswscale/arm/swscale_arm.c	2019-04-18 13:19:20.283938488 -0700
@@ -0,0 +1,409 @@
+/*
+ * AltiVec-enhanced yuv2yuvX
+ *
+ * based on the equivalent C code in swscale.c
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <inttypes.h>
+
+#include "config.h"
+#include "libswscale/swscale.h"
+#include "libswscale/swscale_internal.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include <arm_neon.h>
+
+#include <stdio.h>
+
+#define PLD_NEXT(pointer) 				\
+	asm( "pld [%0, #256] \n\t" : : "r"(pointer));
+
+static int ypfirst = 1;
+static int hsfirst = 1;
+
+static inline int16_t filter_once(int filterSize,
+		const int16_t *filter, int16x8_t filterMask ,
+		uint16x8_t rowSrcA, uint16x8_t rowSrcB)
+{
+	int val;
+	int32x4_t mult;
+	int32x2_t aggregate;
+	int16_t filter9;
+	int16x8_t filterVec;
+
+	filterVec = vld1q_s16(filter);
+	if (filterSize > 8)
+		filter9 = filter[8];
+	PLD_NEXT(filter);
+
+	if (filterSize < 8)
+		filterVec = vandq_s16(filterMask,filterVec);
+
+	//now the two filters have 4 16u each.
+	if (filterSize > 8){
+		val = vgetq_lane_u16(rowSrcB,0) * filter9 ;
+	} else
+		val=0;
+
+	mult = vdupq_n_u32(0);
+	mult = vmlal_s16(mult,vget_low_s16(filterVec), vget_low_s16(rowSrcA));
+	mult = vmlal_s16(mult,vget_high_s16(filterVec), vget_high_s16(rowSrcA));
+	aggregate = vpadd_s32(vget_low_s32(mult), vget_high_s32(mult));
+	aggregate = vpadd_s32(aggregate, aggregate);
+	val+=vget_lane_s32(aggregate,0);
+
+	return FFMIN(val >> 7, (1 << 15) - 1);
+}
+
+static inline void hScale8To15_arm_template(SwsContext *c, int16_t *dst, int dstW,
+		const uint8_t *src, const int16_t *filter,
+		const int32_t *filterPos
+		, int filterSize, int stepSize)
+{
+	int i;
+	uint16x8_t rowSrcA, rowSrcB, rowSrcC;
+	int16x8_t filterMask;
+	int16_t filterMask_array[8];
+	int srcCounter=0;
+	int srcCounterLast;
+	const uint8_t *srcPointer=src;
+	int srcCounterNext;
+	int filterMask_start;
+
+	filterMask_start = filterSize > 8 ? 8 : 0;
+	for (i=filterMask_start; i<filterSize-filterMask_start; i++)
+		filterMask_array[i]=-1;
+	for (i=filterSize-filterMask_start; i<8; i++)
+		filterMask_array[i]=0;
+	filterMask=vld1q_u16(filterMask_array);
+
+	if ((uintptr_t)srcPointer&0x7)
+		fprintf(stderr, "ERROR! src Pointer not aligned!(%d)/n",(uintptr_t)srcPointer&0x7);
+	rowSrcA = vmovl_u8(vld1_u8(srcPointer));
+	srcPointer+=8;
+	rowSrcB = vmovl_u8(vld1_u8(srcPointer));
+	srcPointer+=8;
+	i=0;
+	srcCounterNext = filterPos[0];
+	//Loop-entry: a few first pixels might have
+	//0 for "filterpos". handle it outside the loop
+	//so we don't have to check inside the loop.
+	while (!srcCounterNext) {
+		dst[i] = filter_once(filterSize, filter, filterMask, rowSrcA, rowSrcB);;
+		filter +=filterSize;
+		i++;
+		srcCounterNext = filterPos[i];
+		PLD_NEXT(filterPos+i);
+	}
+	srcCounterLast =  filterPos[dstW-filterSize];
+	while (srcCounter < srcCounterLast) {
+		int internalCount;
+		//8-wide buffer
+		rowSrcC = vmovl_u8(vld1_u8(srcPointer));
+		srcPointer+=8;
+		PLD_NEXT(srcPointer);
+
+		for (internalCount=0;internalCount<8/stepSize; internalCount++)
+		{
+			if (stepSize ==1) {
+				srcCounter++;
+				rowSrcA = vextq_u16(rowSrcA, rowSrcB,1);
+				rowSrcB = vextq_u16(rowSrcB, rowSrcC,1);
+				rowSrcC = vextq_u16(rowSrcC, rowSrcC,1);
+			} else {
+				srcCounter+=2;
+				rowSrcA = vextq_u16(rowSrcA, rowSrcB,2);
+				rowSrcB = vextq_u16(rowSrcB, rowSrcC,2);
+				rowSrcC = vextq_u16(rowSrcC, rowSrcC,2);
+			}
+			//*TODO: this "if" is cheating, and works only for shrinking
+			//with unnoticable visual difference
+			//a "while" would be more correct, but costs some performance
+			//TODO: or does it?
+			if (srcCounter >= srcCounterNext) {
+				dst[i] = filter_once(filterSize, filter, filterMask, rowSrcA, rowSrcB);;
+				filter +=filterSize;
+				i++;
+				srcCounterNext = filterPos[i];
+				PLD_NEXT(filterPos+i);
+			}
+		}
+	}
+
+	//Loop-exit: a few last pixels might have
+	//dstw-1 for "filterpos". handle it outside the loop
+	//so we don't have to check inside the loop.
+	while (i<dstW) {
+		dst[i] = filter_once(filterSize, filter, filterMask, rowSrcA, rowSrcB);;
+		filter +=filterSize;
+		i++;
+		srcCounterNext = filterPos[i];
+		PLD_NEXT(filterPos+i);
+	}
+
+}
+
+extern void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW,
+		const uint8_t *src, const int16_t *filter,
+		const int32_t *filterPos, int filterSize);
+
+static void hScale8To15_arm(SwsContext *c, int16_t *dst, int dstW,
+		const uint8_t *src, const int16_t *filter,
+		const int32_t *filterPos, int filterSize)
+{
+	if (filterSize == 6)
+		hScale8To15_arm_template(c, dst, dstW, src, filter, filterPos, 6, 1);
+	else if (filterSize == 8)
+		hScale8To15_arm_template(c, dst, dstW, src, filter, filterPos, 8, 1);
+	else if (filterSize == 9)
+		hScale8To15_arm_template(c, dst, dstW, src, filter, filterPos, 9, 2);
+	else {
+		hScale8To15_c(c, dst, dstW, src, filter, filterPos, filterSize);
+		if(hsfirst) {
+			fprintf(stderr, "filtersize not supported by hScale8To15_arm! (%d)\n",filterSize);
+			hsfirst = 0;
+		}
+		return;
+	}
+	if(hsfirst) {
+		fprintf(stderr, "filtersize supported by hScale8To15_arm! (%d)\n",filterSize);
+		hsfirst = 0;
+	}
+}
+
+static inline void yuv2planeX_8_arm_template(const int16_t *filter, int filterSize,
+		const int16_t **src, uint8_t *dest, int dstW,
+		const uint8_t *dither, int offset)
+{
+	int i;
+
+	int32x4_t valsA, valsB;
+
+	int16x4_t destA_t, destB_t;
+	int16x8_t dest_t;
+	uint8x8_t destVec;
+	int32x4_t ditherA, ditherB;
+	int16x4_t srcLoader;
+	int16x4_t filterVecA, filterVecB, filterVecC;
+
+	ditherA=vdupq_n_u32(0);
+	ditherB=vdupq_n_u32(0);
+	ditherA=vsetq_lane_s16(dither[(offset + 0) & 7] << 12,ditherA,0);
+	ditherA=vsetq_lane_s16(dither[(offset + 1) & 7] << 12,ditherA,1);
+	ditherA=vsetq_lane_s16(dither[(offset + 2) & 7] << 12,ditherA,2);
+	ditherA=vsetq_lane_s16(dither[(offset + 3) & 7] << 12,ditherA,3);
+	ditherB=vsetq_lane_s16(dither[(offset + 4) & 7] << 12,ditherB,0);
+	ditherB=vsetq_lane_s16(dither[(offset + 5) & 7] << 12,ditherB,1);
+	ditherB=vsetq_lane_s16(dither[(offset + 6) & 7] << 12,ditherB,2);
+	ditherB=vsetq_lane_s16(dither[(offset + 7) & 7] << 12,ditherB,3);
+
+	filterVecA = vld1_s16(filter);
+	if (filterSize > 4)
+		filterVecB = vld1_s16(filter+4);
+	if (filterSize > 8)
+		filterVecC = vld1_s16(filter+8);
+
+	if (filterSize < 12)
+		filterVecC=vset_lane_s16(0,filterVecC,3);
+	if (filterSize < 11)
+		filterVecC=vset_lane_s16(0,filterVecC,2);
+	if (filterSize < 10)
+		filterVecC=vset_lane_s16(0,filterVecC,1);
+	if (filterSize < 9)
+		filterVecC=vset_lane_s16(0,filterVecC,0);
+	if (filterSize < 8)
+		filterVecB=vset_lane_s16(0,filterVecB,3);
+	if (filterSize < 7)
+		filterVecB=vset_lane_s16(0,filterVecB,2);
+	if (filterSize < 6)
+		filterVecB=vset_lane_s16(0,filterVecB,1);
+	if (filterSize < 5)
+		filterVecB=vset_lane_s16(0,filterVecB,0);
+	if (filterSize < 4)
+		filterVecA=vset_lane_s16(0,filterVecA,3);
+	if (filterSize < 3)
+		filterVecA=vset_lane_s16(0,filterVecA,2);
+	if (filterSize < 2)
+		filterVecA=vset_lane_s16(0,filterVecA,1);
+
+	for (i=0; i<dstW; i+=8) {
+		valsA = ditherA;
+		valsB = ditherB;
+
+		srcLoader=vld1_s16(src[0]+i);
+		valsA = vmlal_lane_s16(valsA, srcLoader, filterVecA, 0);
+		srcLoader=vld1_s16(src[0]+i+4);
+		valsB = vmlal_lane_s16(valsB, srcLoader, filterVecA, 0);
+		PLD_NEXT(src[0]+i);
+		if (filterSize > 1) {
+			srcLoader=vld1_s16(src[1]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecA, 1);
+			srcLoader=vld1_s16(src[1]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecA, 1);
+			PLD_NEXT(src[1]+i);
+		}
+		if (filterSize > 2) {
+			srcLoader=vld1_s16(src[2]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecA, 2);
+			srcLoader=vld1_s16(src[2]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecA, 2);
+			PLD_NEXT(src[2]+i);
+		}
+		if (filterSize > 3) {
+			srcLoader=vld1_s16(src[3]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecA, 3);
+			srcLoader=vld1_s16(src[3]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecA, 3);
+			PLD_NEXT(src[3]+i);
+		}
+		if (filterSize > 4) {
+			srcLoader=vld1_s16(src[4]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecB, 0);
+			srcLoader=vld1_s16(src[4]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecB, 0);
+			PLD_NEXT(src[4]+i);
+		}
+		if (filterSize > 5) {
+			srcLoader=vld1_s16(src[5]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecB, 1);
+			srcLoader=vld1_s16(src[5]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecB, 1);
+			PLD_NEXT(src[5]+i);
+		}
+		if (filterSize > 6) {
+			srcLoader=vld1_s16(src[6]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecB, 2);
+			srcLoader=vld1_s16(src[6]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecB, 2);
+			PLD_NEXT(src[6]+i);
+		}
+		if (filterSize > 7) {
+			srcLoader=vld1_s16(src[7]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecB, 3);
+			srcLoader=vld1_s16(src[7]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecB, 3);
+			PLD_NEXT(src[7]+i);
+		}
+		if (filterSize > 8) {
+			srcLoader=vld1_s16(src[8]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecC, 0);
+			srcLoader=vld1_s16(src[8]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecC, 0);
+			PLD_NEXT(src[8]+i);
+		}
+		if (filterSize > 9) {
+			srcLoader=vld1_s16(src[9]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecC, 1);
+			srcLoader=vld1_s16(src[9]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecC, 1);
+			PLD_NEXT(src[9]+i);
+		}
+		if (filterSize > 10) {
+			srcLoader=vld1_s16(src[10]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecC, 2);
+			srcLoader=vld1_s16(src[10]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecC, 2);
+			PLD_NEXT(src[10]+i);
+		}
+		if (filterSize > 11) {
+			srcLoader=vld1_s16(src[11]+i);
+			valsA = vmlal_lane_s16(valsA, srcLoader, filterVecC, 3);
+			srcLoader=vld1_s16(src[11]+i+4);
+			valsB = vmlal_lane_s16(valsB, srcLoader, filterVecC, 3);
+			PLD_NEXT(src[11]+i);
+		}
+
+		valsA=vshrq_n_s32(valsA,16);
+		valsB=vshrq_n_s32(valsB,16);
+
+		destA_t = vshrn_n_s32(valsA, 3);
+		destB_t = vshrn_n_s32(valsB, 3);
+		dest_t = vcombine_s16(destA_t,destB_t);
+		destVec = vqmovun_s16(dest_t);
+		vst1_u8(dest+i, destVec);
+	}
+}
+
+extern void yuv2planeX_8_c(const int16_t *filter, int filterSize,
+		const int16_t **src, uint8_t *dest, int dstW,
+		const uint8_t *dither, int offset);
+
+static void yuv2planeX_8_arm(const int16_t *filter, int filterSize,
+		const int16_t **src, uint8_t *dest, int dstW,
+		const uint8_t *dither, int offset)
+{
+	if (filterSize==1)
+		yuv2planeX_8_arm_template(filter, 1, src, dest, dstW, dither, offset);
+	else if (filterSize==2)
+		yuv2planeX_8_arm_template(filter, 2, src, dest, dstW, dither, offset);
+	else if (filterSize==3)
+		yuv2planeX_8_arm_template(filter, 3, src, dest, dstW, dither, offset);
+	else if (filterSize==4)
+		yuv2planeX_8_arm_template(filter, 4, src, dest, dstW, dither, offset);
+	else if (filterSize==5)
+		yuv2planeX_8_arm_template(filter, 5, src, dest, dstW, dither, offset);
+	else if (filterSize==6)
+		yuv2planeX_8_arm_template(filter, 6, src, dest, dstW, dither, offset);
+	else if (filterSize==7)
+		yuv2planeX_8_arm_template(filter, 7, src, dest, dstW, dither, offset);
+	else if (filterSize==8)
+		yuv2planeX_8_arm_template(filter, 8, src, dest, dstW, dither, offset);
+	else if (filterSize==9)
+		yuv2planeX_8_arm_template(filter, 9, src, dest, dstW, dither, offset);
+	else if (filterSize==10)
+		yuv2planeX_8_arm_template(filter, 10, src, dest, dstW, dither, offset);
+	else if (filterSize==11)
+		yuv2planeX_8_arm_template(filter, 11, src, dest, dstW, dither, offset);
+	else if (filterSize==12)
+		yuv2planeX_8_arm_template(filter, 12, src, dest, dstW, dither, offset);
+	else {
+		yuv2planeX_8_c(filter, filterSize, src, dest, dstW, dither, offset);
+		if(ypfirst) {
+			fprintf(stderr, "filtersize not supported in yuv2planeX_8_arm! (%d)\n",filterSize);
+			ypfirst = 0;
+		}
+		return;
+	}
+	if(ypfirst) {
+		fprintf(stderr, "filtersize supported in yuv2planeX_8_arm! (%d)\n",filterSize);
+		ypfirst = 0;
+	}
+}
+
+av_cold void ff_sws_init_swscale_arm(SwsContext *c)
+{
+	if ((c->srcBpc == 8) && (c->dstBpc <= 14)) {
+		c->hyScale = c->hcScale = hScale8To15_arm;
+	}
+	fprintf(stderr, "Not using hScale8To15_arm c->srcBpc: %d, c->dstBpc:%d\n", c->srcBpc, c->dstBpc);
+}
+
+void ff_sws_init_output_funcs_arm(SwsContext *c,
+		yuv2planarX_fn *yuv2planeX)
+{
+	enum AVPixelFormat dstFormat = c->dstFormat;
+
+	if (is16BPS(dstFormat)) {
+		fprintf(stderr, "Not using yuv2planeX_8_arm is16BPS \n");
+	} else if (isNBPS(dstFormat)) {
+		fprintf(stderr, "Not using yuv2planeX_8_arm is9_OR_10BPS \n");
+	} else {
+		*yuv2planeX=yuv2planeX_8_arm;
+	}
+}
diff -Nru ../FFmpeg-n4.0.4/libswscale/output.c ./libswscale/output.c
--- ../FFmpeg-n4.0.4/libswscale/output.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libswscale/output.c	2019-04-18 13:19:20.283938488 -0700
@@ -36,6 +36,8 @@
 #include "swscale.h"
 #include "swscale_internal.h"
 
+#include "synoconfig.h"
+
 DECLARE_ALIGNED(8, const uint8_t, ff_dither_2x2_4)[][8] = {
 {  1,   3,   1,   3,   1,   3,   1,   3, },
 {  2,   0,   2,   0,   2,   0,   2,   0, },
@@ -278,7 +280,15 @@
 yuv2NBPS(16, BE, 1, 16, int32_t)
 yuv2NBPS(16, LE, 0, 16, int32_t)
 
+#if defined(SYNO_ALPINE_NEON_LIBSWSCALE)
+void yuv2planeX_8_c(const int16_t *filter, int filterSize,
+                           const int16_t **src, uint8_t *dest, int dstW,
+                           const uint8_t *dither, int offset);
+
+void yuv2planeX_8_c(const int16_t *filter, int filterSize,
+#else
 static void yuv2planeX_8_c(const int16_t *filter, int filterSize,
+#endif
                            const int16_t **src, uint8_t *dest, int dstW,
                            const uint8_t *dither, int offset)
 {
diff -Nru ../FFmpeg-n4.0.4/libswscale/swscale.c ./libswscale/swscale.c
--- ../FFmpeg-n4.0.4/libswscale/swscale.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libswscale/swscale.c	2019-04-18 13:19:20.283938488 -0700
@@ -36,6 +36,8 @@
 #include "swscale_internal.h"
 #include "swscale.h"
 
+#include "synoconfig.h"
+
 DECLARE_ALIGNED(8, const uint8_t, ff_dither_8x8_128)[9][8] = {
     {  36, 68,  60, 92,  34, 66,  58, 90, },
     { 100,  4, 124, 28,  98,  2, 122, 26, },
@@ -116,7 +118,15 @@
 }
 
 // bilinear / bicubic scaling
+#if defined(SYNO_ALPINE_NEON_LIBSWSCALE)
+void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW,
+                          const uint8_t *src, const int16_t *filter,
+                          const int32_t *filterPos, int filterSize);
+
+void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW,
+#else
 static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW,
+#endif
                           const uint8_t *src, const int16_t *filter,
                           const int32_t *filterPos, int filterSize)
 {
@@ -492,6 +502,10 @@
              * this array's tail */
             ff_sws_init_output_funcs(c, &yuv2plane1, &yuv2planeX, &yuv2nv12cX,
                                      &yuv2packed1, &yuv2packed2, &yuv2packedX, &yuv2anyX);
+#if defined(SYNO_ALPINE_NEON_LIBSWSCALE)
+            if (ARCH_ARM) /* Should add check for neon existence */
+                ff_sws_init_output_funcs_arm(c, &yuv2planeX);
+#endif
             use_mmx_vfilter= 0;
             ff_init_vscale_pfn(c, yuv2plane1, yuv2planeX, yuv2nv12cX,
                            yuv2packed1, yuv2packed2, yuv2packedX, yuv2anyX, use_mmx_vfilter);
@@ -564,9 +578,12 @@
                              &c->yuv2nv12cX, &c->yuv2packed1,
                              &c->yuv2packed2, &c->yuv2packedX, &c->yuv2anyX);
 
+#if defined(SYNO_ALPINE_NEON_LIBSWSCALE)
+    if (ARCH_ARM) /* Should add check for neon existence */
+        ff_sws_init_output_funcs_arm(c, &c->yuv2planeX);
+#endif
     ff_sws_init_input_funcs(c);
 
-
     if (c->srcBpc == 8) {
         if (c->dstBpc <= 14) {
             c->hyScale = c->hcScale = hScale8To15_c;
@@ -599,9 +616,10 @@
         ff_sws_init_swscale_x86(c);
     if (ARCH_AARCH64)
         ff_sws_init_swscale_aarch64(c);
-    if (ARCH_ARM)
+#if defined(SYNO_ALPINE_NEON_LIBSWSCALE)
+    if (ARCH_ARM) /* Should add check for neon existence */
         ff_sws_init_swscale_arm(c);
-
+#endif
     return swscale;
 }
 
diff -Nru ../FFmpeg-n4.0.4/libswscale/swscale_internal.h ./libswscale/swscale_internal.h
--- ../FFmpeg-n4.0.4/libswscale/swscale_internal.h	2019-03-27 01:33:52.000000000 -0700
+++ ./libswscale/swscale_internal.h	2019-04-18 13:19:20.283938488 -0700
@@ -33,6 +33,8 @@
 #include "libavutil/pixdesc.h"
 #include "libavutil/ppc/util_altivec.h"
 
+#include "synoconfig.h"
+
 #define STR(s) AV_TOSTRING(s) // AV_STRINGIFY is too long
 
 #define YUVRGB_TABLE_HEADROOM 512
@@ -861,6 +863,10 @@
 void ff_sws_init_swscale_ppc(SwsContext *c);
 void ff_sws_init_swscale_x86(SwsContext *c);
 void ff_sws_init_swscale_aarch64(SwsContext *c);
+#if defined(SYNO_ALPINE_NEON_LIBSWSCALE)
+void ff_sws_init_output_funcs_arm(SwsContext *c,
+                              yuv2planarX_fn *yuv2planeX);
+#endif
 void ff_sws_init_swscale_arm(SwsContext *c);
 
 void ff_hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
diff -Nru ../FFmpeg-n4.0.4/libswscale/utils.c ./libswscale/utils.c
--- ../FFmpeg-n4.0.4/libswscale/utils.c	2019-03-27 01:33:52.000000000 -0700
+++ ./libswscale/utils.c	2019-04-18 13:19:20.283938488 -0700
@@ -1644,8 +1644,12 @@
 #endif /* HAVE_MMXEXT_INLINE */
         {
             const int filterAlign = X86_MMX(cpu_flags)     ? 4 :
+#ifdef SYNO_ALPINE_NEON_LIBSWSCALE
+                                    PPC_ALTIVEC(cpu_flags) ? 8 : 1;
+#else
                                     PPC_ALTIVEC(cpu_flags) ? 8 :
                                     have_neon(cpu_flags)   ? 8 : 1;
+#endif
 
             if ((ret = initFilter(&c->hLumFilter, &c->hLumFilterPos,
                            &c->hLumFilterSize, c->lumXInc,
@@ -1671,8 +1675,12 @@
     /* precalculate vertical scaler filter coefficients */
     {
         const int filterAlign = X86_MMX(cpu_flags)     ? 2 :
+#ifdef SYNO_ALPINE_NEON_LIBSWSCALE
+                                PPC_ALTIVEC(cpu_flags) ? 8 : 1;
+#else
                                 PPC_ALTIVEC(cpu_flags) ? 8 :
                                 have_neon(cpu_flags)   ? 2 : 1;
+#endif
 
         if ((ret = initFilter(&c->vLumFilter, &c->vLumFilterPos, &c->vLumFilterSize,
                        c->lumYInc, srcH, dstH, filterAlign, (1 << 12),
diff -Nru ../FFmpeg-n4.0.4/synoconfig.h ./synoconfig.h
--- ../FFmpeg-n4.0.4/synoconfig.h	1969-12-31 16:00:00.000000000 -0800
+++ ./synoconfig.h	2019-04-18 13:19:20.283938488 -0700
@@ -0,0 +1,134 @@
+#ifndef MY_ABC_HERE
+#define MY_ABC_HERE
+#endif
+
+/* Add ffmpeg option for smooth streaming.
+ * -fragment_url:
+ *  This option can overwrite fragment url in Manifest for smooth streaming.
+ * -fragment_length:
+ *  Let file name of output fragment mp4 with this duration
+ *  This setting dependes on x264 option to make it work
+ * -seek_time:
+ *  Let file name fo output fragment mp4 start with this seek time
+ * See Video Station #659
+ */
+#define SYNO_SMOOTH_STREAMING
+
+/* Fixed h264_parser error in special MP4 remux
+ * some MP4 file could parser error with remain PPS information
+ * See Video Station #944
+ */
+#define SYNO_FIX_MP4_REMUX_H264PARSER
+
+/* filter out some tag that not needed
+ * those tags producted at *.ass convert *.srt
+ * See Video Station #1031
+ */
+#define SYNO_FILTER_SRT_TAGS
+
+/* skip parse_picture in flacdec.c
+ * to avoid gapless playback fails when flac has big embedded cover
+ * See Audio Station #1013
+ */
+#define SYNO_SKIP_FLAC_PARSE_PICTURE
+
+/* add SynoCodecPantent mechanism
+ * h264, mpe4part2, aac , vc1 enc/dec should actived at the first time.
+ * See Video Station #1291
+ */
+/*#if defined(MY_ABC_HERE) || defined(SYNO_AUDIOSTATION) || defined(SYNO_MEDIASERVER) || defined(SYNO_DSM)
+#define SYNO_CODEC_PATENT_G1
+#endif*/
+
+/* let ffmpeg skip audio stream with disabled codec.
+ * e.g. DTS dec/enc ,AC3 enc
+ */
+/*#if !defined(STANDALONE) && !defined(MY_ABC_HERE) && !defined(SYNO_MEDIASERVER)
+#define SYNO_SKIP_DISABLED_AUDIO_STREAM
+#endif*/
+
+/* Optional for writing RIFF info tag to wav
+ * See Media Server #386
+ */
+#define SYNO_WRITE_RIFF_INFO_TAG_TO_WAV
+
+/* Add ffmpeg option for HLS.
+ * -hls_seek_time:
+ *  Let output fragment ts start with this seek time
+ * See Video Station #1758
+ */
+#if defined(MY_ABC_HERE)
+#define SYNO_VIDEOSTATION_HLS_SEEK_TIME
+#endif
+
+/* Fixed core dump when truncate recording in QORIQ platform
+ * See Surveillance bug 1151/1155
+ */
+#define SYNO_FIX_QORIQ_CORE_DUMP
+
+/* Fixed h264_parser error in special MP4 remux
+ * some MP4 file could parser error with remain PPS information
+ * See Video Station #944
+ */
+#define SYNO_FIX_MP4_REMUX_H264PARSER
+
+/* Rule out basename logic in filename setting
+ * Set Name length to 64 rather than fix strlen(%d.ts)
+ */
+#if defined(SYNO_SURVEILLANCESTATION)
+#define SYNO_HLS_COSTUMIZED_TS_NAME
+#endif
+
+/* Use neon acceleration in libswscale, which boosts transcoding
+ * performance on Alpine platform.
+ * The patch is provided by AnnapurnaLabs.
+ * See Video Station #1858
+ */
+#if defined(MY_DEF_HERE)
+#define SYNO_ALPINE_NEON_LIBSWSCALE
+#endif
+
+/* Add ffmpeg option for WEBM.
+ * -webm_seek_time:
+ *  Let output stream with the seek time
+ * See Video Station #2170
+ */
+#if defined(MY_ABC_HERE)
+#define SYNO_VIDEOSTATION_WEBM_SEEK_TIME
+#endif
+
+/* Add skip unknown track config to support dtv streaming with unknown codec track.
+ * add flag "-dtv_skip_unknown" to skip unknown tracks.
+ * See Video Station #2470
+ */
+#if defined(MY_ABC_HERE)
+#define SYNO_DTV_SKIP_UNKNOWN_TRACK
+#endif
+
+/* Add skip visual impaired track config to support dtv streaming with visual impaired track.
+ * add flag "-dtv_skip_visual_impaired" to skip visual impaired tracks.
+ * See Video Station #2525
+ */
+#if defined(MY_ABC_HERE)
+#define SYNO_DTV_SKIP_VISUAL_IMPAIRED_TRACK
+#endif
+
+/* Skip subtitle streams in teletext codec to avoid the abort casued by non monotonically increasing dts.
+ * add flag "-dtv_skip_teletext" to skip subtitle streams in teletext codec.
+ * See Video Station #3925
+ */
+#if defined(MY_ABC_HERE)
+#define SYNO_DTV_SKIP_TELETEXT
+#endif
+
+/* Add skip displaymatrix config to movenc for video station offline transcoding.
+ * add flag "-skip_displaymatrix 1" to mov/mp4 format for skiping writing displaymatrix metadata.
+ * See Video Station #4464
+ */
+#if defined(MY_ABC_HERE)
+#define SYNO_VIDEOSTATION_SKIP_DISPLAYMATRIX
+#endif
+
+#if defined(MY_ABC_HERE)
+#define SYNO_VIDEOSTATION_HLS_COSTUMIZED_TS_NAME
+#endif
